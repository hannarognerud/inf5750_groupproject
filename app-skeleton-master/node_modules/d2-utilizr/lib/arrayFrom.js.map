{"version":3,"sources":["../src/arrayFrom.js"],"names":[],"mappings":";;;;;kBAWwB,SAAS;;;;;;;;;;;;;;;;;;;AAAlB,SAAS,SAAS,CAAC,KAAK,EAAE,QAAQ,EAAE;AAC/C,QAAI,OAAO,GAAG,SAAV,OAAO,CAAY,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;AACzC,YAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;AAC/B,mBAAO,EAAE,CAAC;SACb;;;AAAA,AAGD,YAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;AAC9B,oBAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SACjC;;AAED,YAAI,uBAAuB,EAAE;;AACzB,mBAAO,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,IAAI,CAAC,EAAE,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC;SACnE;;AAED,YAAI,KAAK,GAAG,EAAE;YACV,CAAC;;;AAAC,AAGN,aAAK,GAAG,KAAK,IAAI,CAAC,CAAC;AACnB,WAAG,GAAG,GAAG,GAAI,AAAC,GAAG,GAAG,CAAC,GAAI,QAAQ,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,GAAI,QAAQ,CAAC,MAAM,CAAC;;AAExE,aAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAC1B,iBAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;SAC3B;;AAED,eAAO,KAAK,CAAC;KAChB,CAAC;;AAEF,QAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE;AACvC,eAAO,EAAE,CAAC;KACb;;AAED,QAAI,uBAAQ,KAAK,CAAC,EAAE;AAChB,eAAO,AAAC,QAAQ,GAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;KACjE;;AAED,QAAI,IAAI,UAAU,KAAK,yCAAL,KAAK,CAAA,CAAC;AACxB,QAAI,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,KAAK,QAAQ,KAAK,IAAI,KAAK,UAAU,IAAI,CAAC,KAAK,CAAC,KAAK,CAAA,AAAC,EAAE;;AAEnG,eAAO,OAAO,CAAC,KAAK,CAAC,CAAC;KACzB;;AAED,WAAO,CAAC,KAAK,CAAC,CAAC;CAClB","file":"arrayFrom.js","sourcesContent":["import isArray from './isArray';\n\n/**\n * Create an array from a value\n *\n * @param {*} param Value to transform to an array\n * @param {boolean} [isNewRef] Should return a new reference than the one from the `param` value\n * @returns {Array} The resulting array\n *\n * @requires isArray\n */\nexport default function arrayFrom(param, isNewRef) {\n    var toArray = function(iterable, start, end) {\n        if (!iterable || !iterable.length) {\n            return [];\n        }\n\n        // FIXME: This will never be called as the if check excludes type string\n        if (typeof iterable === 'string') {\n            iterable = iterable.split('');\n        }\n\n        if (supportsSliceOnNodeList) { // FIXME: This does not exist\n            return slice.call(iterable, start || 0, end || iterable.length);\n        }\n\n        var array = [],\n            i;\n\n        // FIXME: start and end are always 0 and iterable.length\n        start = start || 0;\n        end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;\n\n        for (i = start; i < end; i++) {\n            array.push(iterable[i]);\n        }\n\n        return array;\n    };\n\n    if (param === undefined || param === null) {\n        return [];\n    }\n\n    if (isArray(param)) {\n        return (isNewRef) ? Array.prototype.slice.call(param) : param;\n    }\n\n    var type = typeof param;\n    if (param && param.length !== undefined && type !== 'string' && (type !== 'function' || !param.apply)) {\n        // TODO: This function call will always fail because of supportsSliceOnNodeList being undefined\n        return toArray(param);\n    }\n\n    return [param];\n}\n"]}