{"version":3,"sources":["../../src/model/ModelBase.js"],"names":[],"mappings":"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","file":"ModelBase.js","sourcesContent":["import ModelValidation from './ModelValidation';\nimport { isValidUid } from '../lib/check';\n\nconst modelValidator = ModelValidation.getModelValidation();\n\nexport const DIRTY_PROPERTY_LIST = Symbol('List to keep track of dirty properties');\n\nfunction hasModelValidationForProperty(model, property) {\n    return Boolean(model.modelDefinition &&\n        model.modelDefinition.modelValidations &&\n        model.modelDefinition.modelValidations[property] &&\n        Object.prototype.hasOwnProperty.call(model.modelDefinition.modelValidations, property));\n}\n\nfunction updateModelFromResponseStatus(result) {\n    if (\n        result &&\n        result.response.importCount.imported === 1 &&\n        isValidUid(result.response.lastImported)\n    ) {\n        this.dataValues.id = result.response.lastImported;\n        this.dataValues.href = [this.modelDefinition.apiEndpoint, this.dataValues.id].join('/');\n    }\n    this.dirty = false;\n    this.getDirtyChildren()\n        .forEach(value => {\n            value.dirty = false; // eslint-disable-line no-param-reassign\n        });\n\n    this[DIRTY_PROPERTY_LIST].clear();\n    return result;\n}\n\n/**\n * @class ModelBase\n */\nclass ModelBase {\n    /**\n     * @method create\n     *\n     * @returns {Promise} Returns a promise that resolves when the model has been saved or rejected with the result from\n     * the `validate()` call.\n     *\n     * @definition\n     * Will save model as a new object to the server using a POST request. This method would generally be used if\n     * you're creating models with pre-specified IDs. Note that this does not check if the model is marked as dirty.\n     */\n    create() {\n        return this.validate()\n            .then(validationState => {\n                if (!validationState.status) {\n                    return Promise.reject(validationState);\n                }\n\n                return this.modelDefinition\n                    .saveNew(this)\n                    .then(updateModelFromResponseStatus.bind(this));\n            });\n    }\n\n    /**\n     * @method save\n     *\n     * @returns {Promise} Returns a promise that resolves when the model has been saved\n     * or rejects with the result from the `validate()` call.\n     *\n     * @description\n     * Checks if the model is dirty. When the model is dirty it will check if the values of the model are valid by calling\n     * `validate`. If this is correct it will attempt to save the [Model](#/model/Model) to the api.\n     *\n     * ```js\n     * myModel.save()\n     *   .then((message) => console.log(message));\n     * ```\n     */\n    save(includeChildren) {\n        if (!this.isDirty(includeChildren)) {\n            return Promise.reject('No changes to be saved');\n        }\n\n        return this.validate()\n            .then(validationState => {\n                if (!validationState.status) {\n                    return Promise.reject(validationState);\n                }\n\n                return this.modelDefinition\n                    .save(this)\n                    .then(updateModelFromResponseStatus.bind(this));\n            });\n    }\n\n    /**\n     * @method validate\n     *\n     * @returns {Promise} Promise that resolves with an object with a status property that represents if the model\n     * is valid or not the fields array will return the names of the fields that are invalid.\n     *\n     * @description\n     * This will run the validations on the properties which have validations set. Normally these validations are defined\n     * through the DHIS2 schema. It will check min/max for strings/numbers etc. Additionally it will\n     * run model validations against the schema.\n     *\n     * ```js\n     * myModel.validate()\n     *  .then(myModelStatus => {\n     *    if (myModelStatus.status === false) {\n     *      myModelStatus.fields.forEach((fieldName) => console.log(fieldName));\n     *    }\n     * });\n     * ```\n     */\n    validate() {\n        return new Promise((resolve, reject) => {\n            let validationMessages = [];\n\n            function unique(current, property) {\n                if (property && current.indexOf(property) === -1) {\n                    current.push(property);\n                }\n                return current;\n            }\n\n            function asyncRemoteValidation(model) {\n                return modelValidator.validateAgainstSchema(model);\n            }\n\n            // Run async validation against the api\n            asyncRemoteValidation(this)\n                .then(remoteMessages => {\n                    validationMessages = validationMessages.concat(remoteMessages);\n\n                    const validationState = {\n                        status: remoteMessages.length === 0,\n                        fields: validationMessages\n                            .map(validationMessage => validationMessage.property)\n                            .reduce(unique, []),\n                        messages: validationMessages,\n                    };\n                    resolve(validationState);\n                })\n                .catch(message => reject(message));\n        });\n    }\n\n    delete() {\n        return this.modelDefinition.delete(this);\n    }\n\n    isDirty(includeChildren = true) {\n        if (!(this.dirty || includeChildren === true && this.hasDirtyChildren())) {\n            return false;\n        }\n        return true;\n    }\n\n    getDirtyPropertyNames() {\n        return Array.from(this[DIRTY_PROPERTY_LIST].values());\n    }\n\n    getCollectionChildren() {\n        // TODO: Can't be sure that this has a `modelDefinition` property\n        return Object.keys(this)\n            .filter(\n                propertyName => this[propertyName] &&\n                hasModelValidationForProperty(this, propertyName) &&\n                this.modelDefinition.modelValidations[propertyName].owner &&\n                this[propertyName].size >= 0\n            )\n            .map(propertyName => this[propertyName]);\n    }\n\n    getCollectionChildrenPropertyNames() {\n        return Object\n            .keys(this)\n            .filter((propertyName) =>\n                this.modelDefinition &&\n                this.modelDefinition.modelValidations &&\n                this.modelDefinition.modelValidations[propertyName] &&\n                this.modelDefinition.modelValidations[propertyName].type === 'COLLECTION'\n            );\n    }\n\n    getDirtyChildren() {\n        return this.getCollectionChildren()\n            .filter(property => property && (property.dirty === true));\n    }\n\n    hasDirtyChildren() {\n        return this.getDirtyChildren().length > 0;\n    }\n}\n\nexport default new ModelBase();\n"]}