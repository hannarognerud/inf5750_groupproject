'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _libCheck = require('../lib/check');

var _externalJquery = require('../external/jquery');

var _externalJquery2 = _interopRequireDefault(_externalJquery);

var _systemSystem = require('../system/System');

var _systemSystem2 = _interopRequireDefault(_systemSystem);

function getMergeStrategyParam() {
    var mergeType = arguments.length <= 0 || arguments[0] === undefined ? 'REPLACE' : arguments[0];

    var system = _systemSystem2['default'].getSystem();

    if (system.version && Number(system.version.minor) <= 22) {
        return 'mergeStrategy=' + mergeType;
    }

    return 'mergeMode=' + mergeType;
}

function processSuccess(resolve) {
    return function (data /* , textStatus, jqXHR */) {
        resolve(data);
    };
}

function processFailure(reject) {
    return function (jqXHR /* , textStatus, errorThrown */) {
        if (jqXHR.responseJSON) {
            return reject(jqXHR.responseJSON);
        }

        delete jqXHR.then; // eslint-disable-line no-param-reassign
        return reject(jqXHR);
    };
}

function getUrl(baseUrl, url) {
    // If we are dealing with an absolute url use that instead
    if (new RegExp('^(:?https?:)?//').test(url)) {
        return url;
    }

    var urlParts = [];

    if (baseUrl) {
        urlParts.push(baseUrl);
    }
    urlParts.push(url);

    return urlParts.join('/').replace(new RegExp('(.(?:[^:]))\/\/+', 'g'), '$1/').replace(new RegExp('\/$'), '');
}

var Api = (function () {
    function Api(jquery) {
        _classCallCheck(this, Api);

        if (!jquery) {
            throw new Error('D2 requires jQuery');
        }

        this.jquery = jquery;
        this.baseUrl = '/api';
        this.defaultRequestSettings = {
            headers: {
                // FIXME: Remove the 'Cache-Control: no-store' header when we figure out how to solve this xhr/jquery bug
                // does not process consecutive requests for the same url properly due to the 304 response.
                // It makes no sense to set a 'Cache-Control: no-store' on a request...
                'Cache-Control': 'no-store'
            },
            data: {},
            contentType: 'application/json',
            type: undefined,
            url: undefined
        };
    }

    _createClass(Api, [{
        key: 'get',
        value: function get(url, data, options) {
            return this.request('GET', getUrl(this.baseUrl, url), data, options);
        }
    }, {
        key: 'post',
        value: function post(url, data, options) {
            // Pass data through JSON.stringify, unless options.contentType is 'text/plain' or false (meaning don't process)
            var payload = options && options.contentType !== undefined && (options.contentType === 'text/plain' || options.contentType === false) ? data : JSON.stringify(data);
            return this.request('POST', getUrl(this.baseUrl, url), payload, options);
        }
    }, {
        key: 'delete',
        value: function _delete(url, options) {
            return this.request('DELETE', getUrl(this.baseUrl, url), undefined, options);
        }
    }, {
        key: 'update',
        value: function update(url, data) {
            var useMergeStrategy = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            // Since we are currently using PUT to save the full state back, we have to use mergeMode=REPLACE
            // to clear out existing values
            var urlForUpdate = useMergeStrategy === true ? url + '?' + getMergeStrategyParam() : url;

            return this.request('PUT', getUrl(this.baseUrl, urlForUpdate), JSON.stringify(data));
        }
    }, {
        key: 'request',
        value: function request(type, url, data) {
            var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

            (0, _libCheck.checkType)(type, 'string', 'Request type');
            (0, _libCheck.checkType)(url, 'string', 'Url');
            var requestUrl = url;

            if (data && data.filter) {
                var urlQueryParams = data.filter
                // `${str}${separator}${filter}`
                .reduce(function (str, filter) {
                    var separator = str.length ? '&' : '';
                    var filterQuery = 'filter=' + filter;

                    return '' + str + separator + filterQuery;
                }, '');

                delete data.filter; // eslint-disable-line no-param-reassign
                requestUrl += '?' + urlQueryParams;
            }

            var api = this;

            function getOptions(mergeOptions, requestData) {
                var payload = requestData;
                if (payload === undefined) {
                    payload = {};
                } else if (payload === true || payload === false) {
                    payload = payload.toString();
                }

                var resultOptions = Object.assign({}, api.defaultRequestSettings, mergeOptions);

                resultOptions.type = type;
                resultOptions.url = requestUrl;
                resultOptions.data = payload;
                resultOptions.dataType = options.dataType !== undefined ? options.dataType : 'json';
                resultOptions.contentType = options.contentType !== undefined ? options.contentType : 'application/json';

                // Only set content type when there is data to send
                // GET requests and requests without data do not need a Content-Type header
                // 0 and false are valid requestData values and therefore should have a content type
                if (type === 'GET' || !requestData && requestData !== 0 && requestData !== false) {
                    resultOptions.contentType = undefined;
                }

                return resultOptions;
            }

            return new Promise(function (resolve, reject) {
                api.jquery.ajax(getOptions(options, data)).then(processSuccess(resolve), processFailure(reject));
            });
        }
    }, {
        key: 'setBaseUrl',
        value: function setBaseUrl(baseUrl) {
            (0, _libCheck.checkType)(baseUrl, 'string', 'Base url');

            this.baseUrl = baseUrl;

            return this;
        }
    }]);

    return Api;
})();

function getApi() {
    if (getApi.api) {
        return getApi.api;
    }
    return getApi.api = new Api(_externalJquery2['default']);
}

Api.getApi = getApi;

exports['default'] = Api;
module.exports = exports['default'];
//# sourceMappingURL=Api.js.map