{"version":3,"sources":["../../src/pager/Pager.js"],"names":[],"mappings":";;;;;;;;;;wBAA0B,cAAc;;;;;;;;;IAQlC,KAAK;;;;;;;;;;;;AAWI,WAXT,KAAK,GAcL;QAFE,KAAK,yDAAG,EAAE,IAAI,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE;QACjC,aAAa,yDAAG,EAAE,IAAI,EAAE;eAAM,OAAO,CAAC,MAAM,CAAC,sBAAsB,CAAC;OAAA,EAAE;;0BAbxE,KAAK;;;;;AAkBH,QAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;;;;;AAKvB,QAAI,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;;;;;;;;;AASjC,QAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;;;;;;;;AAQzB,QAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;;;;;;;;AAQ/B,QAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;;AAE/B,QAAI,CAAC,aAAa,GAAG,aAAa,CAAC;GACtC;;;;;;;;;;;eAnDC,KAAK;;WA6DI,uBAAG;AACV,aAAO,yBAAU,IAAI,CAAC,QAAQ,CAAC,CAAC;KACnC;;;;;;;;;;;;WAUc,2BAAG;AACd,aAAO,yBAAU,IAAI,CAAC,QAAQ,CAAC,CAAC;KACnC;;;;;;;;;;WAQU,uBAAG;AACV,UAAI,IAAI,CAAC,WAAW,EAAE,EAAE;AACpB,eAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;OACvC;AACD,aAAO,OAAO,CAAC,MAAM,CAAC,2CAA2C,CAAC,CAAC;KACtE;;;;;;;;;;WAQc,2BAAG;AACd,UAAI,IAAI,CAAC,eAAe,EAAE,EAAE;AACxB,eAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;OACvC;AACD,aAAO,OAAO,CAAC,MAAM,CAAC,+CAA+C,CAAC,CAAC;KAC1E;;;;;;;;;;;WASO,kBAAC,MAAM,EAAE;AACb,UAAI,MAAM,GAAG,CAAC,EAAE;AACZ,cAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;OACpD;AACD,UAAI,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;AACzB,cAAM,IAAI,KAAK,4DAA0D,IAAI,CAAC,SAAS,CAAG,CAAC;OAC9F;;AAED,aAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;KACpD;;;SAvHC,KAAK;;;qBA0HI,KAAK","file":"Pager.js","sourcesContent":["import { isDefined } from '../lib/check';\n\n/**\n * @class Pager\n *\n * @description\n * Pager object that can be used to navigate pages within a `Modelcollection`\n */\nclass Pager {\n\n    /**\n     * @constructor\n     *\n     * @param {Object} [pager={page: 1, pageCount: 1}] Paging information object.\n     * @param {Object} [pagingHandler={list: () => Promise.reject('No handler available')}] Paging handler object. The requirement for this object is that it has a list method.\n     *\n     * @description\n     * Returns a newly created pager object with methods to navigate pages.\n     */\n    constructor(\n        pager = { page: 1, pageCount: 1 },\n        pagingHandler = { list: () => Promise.reject('No handler available') }\n    ) {\n        /**\n         * @property {number} page Current page number\n         */\n        this.page = pager.page;\n\n        /**\n         * @property {number} pageCount The total number of pages available\n         */\n        this.pageCount = pager.pageCount;\n\n        /**\n         * @property {number} total The total number of items available.\n         *\n         * @description\n         * This represents the total number of items available in the system. Note it is not the number of items\n         * on the current page.\n         */\n        this.total = pager.total;\n\n        /**\n         * @property {string} nextPage The url to the next page.\n         *\n         * @description\n         * If there is no next page then this will be undefined.\n         */\n        this.nextPage = pager.nextPage;\n\n        /**\n         * @property {string} prevPage The url to the previous page\n         *\n         * @description\n         * If there is no previous page then this will be undefined.\n         */\n        this.prevPage = pager.prevPage;\n\n        this.pagingHandler = pagingHandler;\n    }\n\n    /**\n     * @method hasNextPage\n     *\n     * @returns {Boolean} Result is true when there is a next page, false when there is not.\n     *\n     * @description\n     * Check whether there is a next page.\n     */\n    hasNextPage() {\n        return isDefined(this.nextPage);\n    }\n\n    /**\n     * @method hasPreviousPage\n     *\n     * @returns {Boolean} Result is true when there is a previous page, false when there is not.\n     *\n     * @description\n     * Check whether there is a previous page.\n     */\n    hasPreviousPage() {\n        return isDefined(this.prevPage);\n    }\n\n    /**\n     * @method getNextPage\n     *\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the next page's data. Or rejects with\n     * a string when there is no next page for this collection or when the request for the next page failed.\n     */\n    getNextPage() {\n        if (this.hasNextPage()) {\n            return this.goToPage(this.page + 1);\n        }\n        return Promise.reject('There is no next page for this collection');\n    }\n\n    /**\n     * @method getPreviousPage\n     *\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the previous page's data. Or rejects with\n     * a string when there is no previous page for this collection or when the request for the previous page failed.\n     */\n    getPreviousPage() {\n        if (this.hasPreviousPage()) {\n            return this.goToPage(this.page - 1);\n        }\n        return Promise.reject('There is no previous page for this collection');\n    }\n\n    /**\n     * @method goToPage\n     *\n     * @param {Number} pageNr The number of the page you wish to navigate to.\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the data for the requested page.\n     */\n    // TODO: Throwing the errors here is not really consistent with the rejection of promises for the getNextPage and getPreviousPage\n    goToPage(pageNr) {\n        if (pageNr < 1) {\n            throw new Error('PageNr can not be less than 1');\n        }\n        if (pageNr > this.pageCount) {\n            throw new Error(`PageNr can not be larger than the total page count of ${this.pageCount}`);\n        }\n\n        return this.pagingHandler.list({ page: pageNr });\n    }\n}\n\nexport default Pager;\n"]}