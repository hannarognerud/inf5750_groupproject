'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _libCheck = require('../lib/check');

/**
 * @class Pager
 *
 * @description
 * Pager object that can be used to navigate pages within a `Modelcollection`
 */

var Pager = (function () {

  /**
   * @constructor
   *
   * @param {Object} [pager={page: 1, pageCount: 1}] Paging information object.
   * @param {Object} [pagingHandler={list: () => Promise.reject('No handler available')}] Paging handler object. The requirement for this object is that it has a list method.
   *
   * @description
   * Returns a newly created pager object with methods to navigate pages.
   */

  function Pager() {
    var pager = arguments.length <= 0 || arguments[0] === undefined ? { page: 1, pageCount: 1 } : arguments[0];
    var pagingHandler = arguments.length <= 1 || arguments[1] === undefined ? { list: function list() {
        return Promise.reject('No handler available');
      } } : arguments[1];

    _classCallCheck(this, Pager);

    /**
     * @property {number} page Current page number
     */
    this.page = pager.page;

    /**
     * @property {number} pageCount The total number of pages available
     */
    this.pageCount = pager.pageCount;

    /**
     * @property {number} total The total number of items available.
     *
     * @description
     * This represents the total number of items available in the system. Note it is not the number of items
     * on the current page.
     */
    this.total = pager.total;

    /**
     * @property {string} nextPage The url to the next page.
     *
     * @description
     * If there is no next page then this will be undefined.
     */
    this.nextPage = pager.nextPage;

    /**
     * @property {string} prevPage The url to the previous page
     *
     * @description
     * If there is no previous page then this will be undefined.
     */
    this.prevPage = pager.prevPage;

    this.pagingHandler = pagingHandler;
  }

  /**
   * @method hasNextPage
   *
   * @returns {Boolean} Result is true when there is a next page, false when there is not.
   *
   * @description
   * Check whether there is a next page.
   */

  _createClass(Pager, [{
    key: 'hasNextPage',
    value: function hasNextPage() {
      return (0, _libCheck.isDefined)(this.nextPage);
    }

    /**
     * @method hasPreviousPage
     *
     * @returns {Boolean} Result is true when there is a previous page, false when there is not.
     *
     * @description
     * Check whether there is a previous page.
     */
  }, {
    key: 'hasPreviousPage',
    value: function hasPreviousPage() {
      return (0, _libCheck.isDefined)(this.prevPage);
    }

    /**
     * @method getNextPage
     *
     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the next page's data. Or rejects with
     * a string when there is no next page for this collection or when the request for the next page failed.
     */
  }, {
    key: 'getNextPage',
    value: function getNextPage() {
      if (this.hasNextPage()) {
        return this.goToPage(this.page + 1);
      }
      return Promise.reject('There is no next page for this collection');
    }

    /**
     * @method getPreviousPage
     *
     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the previous page's data. Or rejects with
     * a string when there is no previous page for this collection or when the request for the previous page failed.
     */
  }, {
    key: 'getPreviousPage',
    value: function getPreviousPage() {
      if (this.hasPreviousPage()) {
        return this.goToPage(this.page - 1);
      }
      return Promise.reject('There is no previous page for this collection');
    }

    /**
     * @method goToPage
     *
     * @param {Number} pageNr The number of the page you wish to navigate to.
     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the data for the requested page.
     */
    // TODO: Throwing the errors here is not really consistent with the rejection of promises for the getNextPage and getPreviousPage
  }, {
    key: 'goToPage',
    value: function goToPage(pageNr) {
      if (pageNr < 1) {
        throw new Error('PageNr can not be less than 1');
      }
      if (pageNr > this.pageCount) {
        throw new Error('PageNr can not be larger than the total page count of ' + this.pageCount);
      }

      return this.pagingHandler.list({ page: pageNr });
    }
  }]);

  return Pager;
})();

exports['default'] = Pager;
module.exports = exports['default'];
//# sourceMappingURL=Pager.js.map