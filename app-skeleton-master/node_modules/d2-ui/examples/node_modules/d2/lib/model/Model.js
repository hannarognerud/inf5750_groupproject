/**
 * @module Model
 *
 * @requires lib/check
 * @requires model/ModelBase
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _libCheck = require('../lib/check');

var _ModelBase = require('./ModelBase');

var _ModelBase2 = _interopRequireDefault(_ModelBase);

// TODO: Perhaps we can generate model classes dynamically based on the schemas and inherit from this.
/**
 * @class Model
 * @extends ModelBase
 *
 * @description
 * A Model represents an object from the DHIS2 Api. A model is created based of a ModelDefinition. The ModelDefinition
 * has the properties that the model should have.
 */

var Model = (function () {

    /**
     * @constructor
     *
     * @param {ModelDefinition} modelDefinition The model definition that corresponds with the model.
     * This is essential defining what type the model is representing.
     *
     * @description
     * Will create a new model instanced based on the model definition. When creating a new instance the model
     * definition needs to have both the modelValidations and modelProperties.
     *
     * The model properties will depend on the ModelDefinition. A model definition is based on a DHIS2 Schema.
     */

    function Model(modelDefinition) {
        var _this = this;

        _classCallCheck(this, Model);

        (0, _libCheck.checkType)(modelDefinition, 'object', 'modelDefinition');
        (0, _libCheck.checkType)(modelDefinition.modelProperties, 'object', 'modelProperties');

        /**
         * @property {ModelDefinition} modelDefinition Stores reference to the modelDefinition that was used when
         * creating the model. This property is not enumerable or writable and will therefore not show up when looping
         * over the object properties.
         */
        Object.defineProperty(this, 'modelDefinition', {
            enumerable: false,
            configurable: false,
            writable: false,
            value: modelDefinition
        });

        /**
         * @property {Boolean} dirty Represents the state of the model. When the model is concidered `dirty`
         * there are pending changes.
         * This property is not enumerable or writable and will therefore not show up when looping
         * over the object properties.
         */
        Object.defineProperty(this, 'dirty', {
            enumerable: false,
            configurable: false,
            writable: true,
            value: false
        });

        /**
         * @property {Object} dataValues Values object used to store the actual model values. Normally access to the
         * Model data will be done through accessor properties that are generated from the modelDefinition.
         *
         * @note {warning} This should not be accessed directly.
         */
        Object.defineProperty(this, 'dataValues', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: {}
        });

        var hasKeys = function hasKeys(object) {
            return object && !!Object.keys(object).length;
        };
        var attributes = {};
        var attributeProperties = modelDefinition.attributeProperties;
        if (hasKeys(attributeProperties)) {
            Object.defineProperty(this, 'attributes', {
                enumerable: false,
                value: attributes
            });

            Object.keys(attributeProperties).forEach(function (attributeName) {
                Object.defineProperty(attributes, attributeName, {
                    enumerable: true,
                    get: function get() {
                        if (!Array.isArray(_this.attributeValues)) {
                            return undefined;
                        }

                        return _this.attributeValues.filter(function (value) {
                            return value.attribute.name === attributeName;
                        }).reduce(function (current, value) {
                            return value.value;
                        }, undefined);
                    },
                    set: function set(value) {
                        if (!_this.attributeValues) {
                            _this.attributeValues = [];
                        }

                        var attributeValue = _this.attributeValues.filter(function (av) {
                            return av.attribute.name === attributeName;
                        }).reduce(function (current, av) {
                            return av;
                        }, undefined);

                        if (attributeValue) {
                            // Don't do anything if the value stayed the same
                            if (attributeValue.value === value) {
                                return;
                            }

                            attributeValue.value = value;
                        } else {
                            // Add the new attribute value to the attributeValues collection
                            _this.attributeValues.push({
                                value: value,
                                attribute: {
                                    id: attributeProperties[attributeName].id,
                                    name: attributeProperties[attributeName].name
                                }
                            });
                        }

                        // Set the model to be dirty
                        _this.dirty = true;
                    }
                });
            });
        }

        Object.defineProperties(this, modelDefinition.modelProperties);

        this[_ModelBase.DIRTY_PROPERTY_LIST] = new Set([]);
    }

    /**
     * @method create
     * @static
     *
     * @param {ModelDefinition} modelDefinition ModelDefinition from which the model should be created
     * @returns {Model} Returns an instance of the model.
     *
     * @description The static method is a factory method to create Model objects. It calls `new Model()` with the passed `ModelDefinition`.
     *
     * ```js
     * let myModel = Model.create(modelDefinition);
     * ```
     */

    _createClass(Model, null, [{
        key: 'create',
        value: function create(modelDefinition) {
            return new Model(modelDefinition);
        }
    }]);

    return Model;
})();

Model.prototype = _ModelBase2['default'];

exports['default'] = Model;
module.exports = exports['default'];
//# sourceMappingURL=Model.js.map