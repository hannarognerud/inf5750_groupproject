'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _libCheck = require('../lib/check');

var FILTER_COMPARATORS = {
    /**
     * @method equals
     * @returns {Filter} Returns the modified filter for chaining
     *
     * @description
     * This method can be used to add a equals filter value
     */
    equals: 'eq',
    /**
     * @method like
     * @returns {Filter} Returns the modified filter for chaining
     *
     * @description
     * This method can be used to add a like filter value
     */
    like: 'like',
    /**
     * @method ilike
     * @returns {Filter} Returns the modified filter for chaining
     *
     * @description
     * This method can be used to add a ilike filter value
     */
    ilike: 'ilike',
    notEqual: 'ne'
};

/**
 * @class Filter
 * @description
 * Filter class that can be used to build api endpoint filters using a semi-natural language style.
 */

var Filter = (function () {
    /**
     * @constructor
     * @param {Filters} filters Filters list that this filter will be added to when it is completed.
     */

    function Filter(filters) {
        _classCallCheck(this, Filter);

        this.filters = filters;
        this.propertyName = 'name';
        this.comparator = 'like';
        this.filterValue = undefined;
    }

    // Add the filters to the Filter prototype
    // TODO: Change to for..of. Currently would break e2e tests because of polyfill

    /**
     * @method on
     * @param {String} propertyName Property name that the filter should be applied on.
     * @returns {Filter}
     */

    _createClass(Filter, [{
        key: 'on',
        value: function on(propertyName) {
            (0, _libCheck.checkDefined)(propertyName, 'Property name to filter on');

            this.propertyName = propertyName;
            return this;
        }
    }, {
        key: 'getQueryParamFormat',
        value: function getQueryParamFormat() {
            return [this.propertyName, this.comparator, this.filterValue].join(':');
        }

        /**
         * @method getFilter
         * @static
         *
         * @param {Filters} filters Filters list that this filter will be added to when it is completed.
         *
         * @returns A instance of the Filter class that can be used to create
         * filters.
         *
         * @description
         * Create a filter instance
         */
    }], [{
        key: 'getFilter',
        value: function getFilter(filters) {
            return new Filter(filters);
        }
    }]);

    return Filter;
})();

Object.keys(FILTER_COMPARATORS).forEach(function (filter) {
    Object.defineProperty(Filter.prototype, filter, {
        value: function filterGetter(filterValue) {
            (0, _libCheck.checkDefined)(filterValue, 'filterValue');

            this.comparator = FILTER_COMPARATORS[filter];
            this.filterValue = filterValue;

            this.filters.add(this);

            return this.filters.getReturn();
        }
    });
});

exports['default'] = Filter;
module.exports = exports['default'];
//# sourceMappingURL=Filter.js.map