'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _libCheck = require('../lib/check');

var _loggerLogger = require('../logger/Logger');

var _loggerLogger2 = _interopRequireDefault(_loggerLogger);

var _apiApi = require('../api/Api');

var _apiApi2 = _interopRequireDefault(_apiApi);

var _helpersJson = require('./helpers/json');

/**
 * @class ModelValidation
 */

var ModelValidation = (function () {
    function ModelValidation(providedLogger) {
        _classCallCheck(this, ModelValidation);

        (0, _libCheck.checkType)(providedLogger, 'object', 'logger (Logger)');
        this.logger = providedLogger;
    }

    /**
     * @deprecated
     * @method validate
     *
     * @returns {{status: boolean, messages: Array}} Returns {status: true, messages: []}
     */

    _createClass(ModelValidation, [{
        key: 'validate',
        value: function validate() {
            this.logger.warn('Client side model validation is deprecated');
            throw new Error('Client side model validation is deprecated');
        }

        /**
         * @method validateAgainstSchema
         *
         * @param {Model} model The model that should be validated.
         * @returns {Array} Returns an array with validation messages if there are any.
         *
         * @description
         * Sends a POST request against the `api/schemas` endpoint to check if the model is valid.
         *
         * @note {warn} Currently only checks
         */
    }, {
        key: 'validateAgainstSchema',
        value: function validateAgainstSchema(model) {
            if (!(model && model.modelDefinition && model.modelDefinition.name)) {
                return Promise.reject('model.modelDefinition.name can not be found');
            }

            function extractValidationViolations(webmessage) {
                // Support both the 2.23+ version using `errorReports` and the 2.22 and lower using `validationViolations`
                // for errorMessages from the schemas endpoint.
                // TODO: Remove support for the older `validationViolations` when supporting 2.22 is no longer required
                if (webmessage.response && (webmessage.response.validationViolations || webmessage.response.errorReports)) {
                    return webmessage.response.validationViolations || webmessage.response.errorReports;
                }
                throw new Error('Response was not a WebMessage with the expected format');
            }

            var url = 'schemas/' + model.modelDefinition.name;

            // TODO: The function getOwnedPropertyJSON should probably not be exposed, perhaps we could have a getJSONForModel(ownedPropertiesOnly=true) method.
            return _apiApi2['default'].getApi().post(url, (0, _helpersJson.getOwnedPropertyJSON)(model)).then(function (webMessage) {
                if (webMessage.status === 'OK') {
                    return [];
                }
                return Promise.reject(webMessage);
            })['catch'](extractValidationViolations);
        }

        /**
         * @method getModelValidation
         * @static
         *
         * @returns {ModelValidation} New or memoized instance of `ModelInstance`
         *
         * @description
         * Returns the `ModelValidation` singleton. Creates a new one if it does not yet exist.
         * Grabs a logger instance by calling `Logger.getLogger`
         */
    }], [{
        key: 'getModelValidation',
        value: function getModelValidation() {
            if (this.modelValidation) {
                return this.modelValidation;
            }
            return this.modelValidation = new ModelValidation(_loggerLogger2['default'].getLogger(console));
        }
    }]);

    return ModelValidation;
})();

exports['default'] = ModelValidation;
module.exports = exports['default'];
//# sourceMappingURL=ModelValidation.js.map